# Cosmos DB 選定指針ドキュメント

## 1. 結論（本ロジック前提）

* **現行ロジックのままなら Cosmos DB for NoSQL が有利**
  浅いトラバーサル（1～2ホップ）が中心であり、ID／ラベル指定のポイントリードや軽量クエリで十分。
  また、Change Feed／Synapse Link／ベクター検索など連携機能が豊富で将来拡張が容易。

* **“グラフらしい”任意パス探索や多段ホップの問い合わせを開放するなら Gremlin API が有利**
  TinkerPop/Gremlin により「隣接」「パス」「中心性」など**グラフ・アルゴリズム寄り**の表現が直感的に可能。
  アドホックな多段トラバーサルを多用するなら検討価値が高い。

---

## 2. ユースケースに基づく比較

| 観点               | Cosmos DB for NoSQL（SQL API）                      | Cosmos DB for Gremlin API                 |
| ---------------- | ------------------------------------------------- | ----------------------------------------- |
| **データ表現**        | 頂点・辺を **ドキュメント** として設計（現実装方針）                     | 頂点・辺を **ネイティブグラフ** モデル（TinkerPop準拠）       |
| **クエリ表現**        | SQLライク＋ポイントリード。アプリ側でトラバーサル制御                      | **Gremlin** により多段ホップやパターンを宣言的に記述          |
| **問い合わせ例**       | テーブル→カラム（1ホップ）、FK先テーブル（2ホップ）は **軽量クエリ or 集約** で十分 | `.out('has_column')` や `.path()` で簡潔に表現   |
| **深い／可変長トラバーサル** | アプリ側実装（往復増加しやすい）                                  | **得意分野**（可変長、パターン一致に強い）                   |
| **インデックス／検索**    | 自動インデックス＋**ベクター検索**あり                             | ベクター検索は **非対応**                           |
| **変更検知／連携**      | **Change Feed**、**Synapse Link** に対応              | Change Feed / Synapse Link は **非対応または限定** |
| **サーバーサイド**      | JS Stored Proc／Trigger／UDF、Transactional Batch あり | Gremlin クエリのみ（サーバーサイドJSなし）                |
| **SDK／ツール充実度**   | **最充実**（.NET, Java, Python…）運用知見豊富                | 主要言語対応だが選択肢は少なめ                           |
| **スキーマ進化**       | ドキュメント柔軟／**多モデル共存**が容易                            | 柔軟だが **API間移行は重い**                        |
| **学習コスト**        | 低：C#・LINQ・SQL 脳で対応可能                              | Gremlin 学習コストあり                           |
| **パーティション設計**    | 現行は `PartitionKey="ecommerce"` 固定。拡張時に再検討余地あり     | 頂点／辺にもPK設計が必要。**跨ぎトラバースでRU増**             |
| **コスト傾向（RU）**    | ポイントリード中心なら **安定・安価**                             | **跨ぎトラバーサルが増えるほど高騰**                      |

> 現行ロジックは「**浅い固定ホップ**」「**ID命名規約で直参照**」「**PK固定**」であり、NoSQL 特性に合致。

---

## 3. 具体的な問い合わせ例

### NoSQL（現行方式；概念例）

* **テーブル→カラム一覧**

  ```sql
  SELECT * FROM c 
  WHERE c.label="column" 
    AND c.table="ecommerce.orders" 
    AND c.pk="ecommerce"
  ```

* **テーブル間のFK先（2ホップ）**

  1. 辺検索

     ```sql
     SELECT c.to FROM e c 
     WHERE c.label="fk" 
       AND c.from="c:orders:customer_id"
     ```
  2. 返却された column-id から属するテーブルを検索

* **最適化**
  テーブルノードに「隣接（FK先／元）ID配列」を冗長保持 → **1クエリ化**可能（NoSQLならではのデノーマライズ）。

### Gremlin（同等処理；概念例）

```gremlin
// テーブル→カラム
g.V('t:orders').out('has_column')

// テーブル→FKで繋がるテーブル
g.V('t:orders').
  out('has_column').has('name','customer_id').
  out('fk').values('table').dedup()
```

* 多段／パターン探索（例：orders→products→categories→親カテゴリ）は Gremlin が簡潔。

---

## 4. 選定指針

**NoSQL が向く条件（今回多く該当）**

* トラバーサルは **1～2ホップ中心**
* API／連携（Change Feed、Synapse Link、ベクター検索）を活用したい
* RU／レイテンシを予測しやすい設計を望む
* 既存C#スタックで短期実装したい

**Gremlin が向く条件**

* ユーザーに **自由探索UI**（任意パス、中心性など）を提供
* クエリ作者が **Gremlin/TinkerPop** に慣れている
* 深い関係探索（データリネージ、ナレッジグラフ、権限グラフなど）が主役

---

## 5. パーティション設計と RU

* **固定PK ("ecommerce")** はシンプルだが将来ホットパーティション化のリスクあり。

  * 代案：`label` や `table` を含むキー設計、または頂点／辺ごとに別コンテナ
  * ホップ元と先を同じPKに寄せる工夫で RU を抑制可能

* **NoSQL での高速化テク**

  * 頂点に隣接リストを冗長保持し **1リクエスト完結**
  * **ポイントリード**を基本とする
  * **Stored Proc**で1～2ホップ結合をサーバーサイド処理

---

## 6. 将来拡張（ハイブリッド運用）

* **現状は NoSQL 継続が最適**
  Change Feed／Synapse Link／Vector Search を活用し、RAG／BI／ETL 連携も広範。

* **探索重視ビューは Gremlin 分離**
  深い到達／可変長探索が必要な場合は **Gremlin専用コンテナ**を別途運用（ETLまたはイベント同期）。
  運用コストは増すがクエリ体験を最適化可能。

---

## 7. 判断チェックリスト

1. クエリの最大ホップ数は？（90%が2ホップ以下 → NoSQL◎）
2. ユーザーに自由探索を許すか？（Yes → Gremlin寄り）
3. RAG／分析連携（Synapse Link／ベクター検索）を使う計画は？（Yes → NoSQL有利）
4. 運用一元化（学習コスト・監視・データ連携）を優先するか？（Yes → NoSQL）
5. 将来の規模に備え、パーティション設計で跨ぎ削減や冗長保持を計画できるか？

---

## 8. まとめ（提案）

* **現行ロジック & 要件（スキーマ可視化・1～2ホップ依存関係）なら NoSQL 継続が最適**

* **即効改善策**

  * テーブルに **FK先／元テーブルID配列**を冗長保持 → 1クエリ化
  * **Change Feed**で依存関係キャッシュを自動更新
  * **Vector Search**で「列名／説明の類似検索」を導入

* **任意パス探索UIを導入する段階**で Gremlin 部分導入を検討。
